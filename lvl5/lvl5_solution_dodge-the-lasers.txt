# LEVEL 5, Task 1 (dodge-the-lasers)



from time import process_time
from decimal import Decimal, localcontext



# BEATTY SEQUENCE
def solution(s):
  with localcontext() as context:
    context.prec = 201

    time_steps = Decimal(s)
    acceleration = Decimal(2).sqrt()
    acceleration_fraction = acceleration % 1

    def calculate_sum(n, acc_frac):
      """sum of a Beatty sequence generated by an irrational number r, where 1 < r < 2

      Args:
        n (Decimal): number until which the sum should be calculated (including n)
        acc_frac (Decimal): fractional part of the irrational number r

      Returns:
        Decimal: sum of the sequence
      """
      if n == 0:
        return 0

      overflow = floored_product(n, acc_frac)
      g_sum = gauss_summation(n + overflow)
      return g_sum - calculate_complement_sum(overflow, acc_frac)

    def calculate_complement_sum(n, acc_frac):
      """sum of a Beatty sequence generated by an irrational number s, where s >= 2

      Args:
        n (Decimal): number until which the sum should be calculated (including n)
        acc_frac (Decimal): fractional part of the irrational number r, where r = s/(s-1)

      Returns:
        Decimal: sum of the sequence
      """
      g_sum = gauss_summation(n)
      return 2*g_sum + calculate_sum(n, acc_frac)

    def gauss_summation(n):
      """sum of integers [1, n].

      Args:
        n (Decimal): number until which the sum should be calculated (including n)

      Returns:
        Decimal: sum of integers from 1 to n (inclusive)
      """
      return n*(n + 1)/Decimal(2)

    def floored_product(n, irrational):
      """product of an integer and an irrational number rounded down to the nearest integer.

      Args:
        n (Decimal): integer part of the product
        irrational (Decimal): irrational part of the product

      Returns:
        Decimal: product of inputs rounded down
      """
      return int(irrational*n)

    calculated_distance = calculate_sum(time_steps, acceleration_fraction)
    return str(int(calculated_distance))


'''
s1 = '77' # -> 4208
s2 = '5' # -> 19
s_exp = '10000'

t1 = process_time()
s = solution(s1)
t2 = process_time()
print('solution', s, 'time:', t2-t1, 'seconds')
'''